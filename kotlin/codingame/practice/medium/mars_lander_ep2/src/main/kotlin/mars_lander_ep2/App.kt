/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package mars_lander_ep2

import java.util.*

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
fun main(args: Array<String>) {
    val input = Scanner(System.`in`)
    val surfaceN = input.nextInt() // the number of points used to draw the surface of Mars.
    val points: MutableList<Point> = mutableListOf();
    var minX: Int = 0
    var maxX: Int = 0
    var maxY: Int = 0

    for (i in 0 until surfaceN) {
        val landX = input.nextInt() // X coordinate of a surface point. (0 to 6999)
        val landY = input.nextInt() // Y coordinate of a surface point. By linking all the points together in a sequential fashion, you form the surface of Mars.
        if (i > 0) {
            val previousPoint = points.get(i - 1)
            if (previousPoint.y == landY) {
                if (landX - previousPoint.x >= 1000) {
                    minX = previousPoint.x
                    maxX = landX
                }
            }
        }
        if (landY > maxY) {
            maxY = landY
        }
        points.add(Point(landX, landY))
    }

    System.err.println("Found flat area between ${minX} and ${maxX}")

    // game loop
    while (true) {
        val X = input.nextInt()
        val Y = input.nextInt()
        val hSpeed = input.nextInt() // the horizontal speed (in m/s), can be negative.
        val vSpeed = input.nextInt() // the vertical speed (in m/s), can be negative.
        val fuel = input.nextInt() // the quantity of remaining fuel in liters.
        val rotate = input.nextInt() // the rotation angle in degrees (-90 to 90).
        val power = input.nextInt() // the thrust power (0 to 4).

        // Write an action using println()
        // To debug: System.err.println("Debug messages...");
        // Where am I ?
        // If above the flatground, that's ok, I have only to descend with
        // - rotation == 0
        // - hSpeed <= 20
        // - vSpeed <= 40
        // If on the left of the minX, I have to rotate negatively and thrust to max to go on left until I am above flat ground
        // If on the right of the maxX, I have to rotate positively and thrust to max to go on right until I am above flat ground
        val answer = when (X) {
            in 0..minX -> goRight(hSpeed, vSpeed, fuel, rotate, power)
            in maxX..6999 -> goLeft(hSpeed, vSpeed, fuel, rotate, power)
            in minX..maxX -> goDown(hSpeed, vSpeed, fuel, rotate, power)
            else -> goDown(hSpeed, vSpeed, fuel, rotate, power)
        }

        // rotate power. rotate is the desired rotation angle. power is the desired thrust power.
        println(answer)
    }
}

fun goDown(hSpeed: Int, vSpeed: Int, fuel: Int, rotate: Int, power: Int): String {
    var result = ""

    if (hSpeed > 19) {
        return "45 4"
    } else if (hSpeed < -19) {
        return "-45 4"
    } else {
        if (vSpeed > 39) {
            result = "0 ${Integer.toString(Math.max(0, power - 1))}"
        } else if (vSpeed < -39) {
            result = "0 ${Integer.toString(Math.min(4, power + 1))}"
        } else {
            result = "0 0"
        }
    }
    return result
}

fun goLeft(hSpeed: Int, vSpeed: Int, fuel: Int, rotate: Int, power: Int): String {
    //return "90 4"
    return if (hSpeed > 19) {
        "45 ${Integer.toString(Math.max(0, power - 1))}"
    } else if (hSpeed < -19) {
        "-45 ${Integer.toString(Math.min(4, power + 1))}"
    } else {
        "0 0"
    }
}

fun goRight(hSpeed: Int, vSpeed: Int, fuel: Int, rotate: Int, power: Int): String {
    return "-90 4"
}

data class Point(val x: Int, val y: Int)
