/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package mars_lander_ep2

import java.util.*

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
fun main(args: Array<String>) {
    val input = Scanner(System.`in`)
    val surfaceN = input.nextInt() // the number of points used to draw the surface of Mars.
    val points: MutableList<Point> = mutableListOf();
    var startOfFlatGround = Point()
    var endOfFlatGround = Point()
    var highestPoint = Point()

    for (i in 0 until surfaceN) {
        val landX = input.nextInt() // X coordinate of a surface point. (0 to 6999)
        val landY = input.nextInt() // Y coordinate of a surface point. By linking all the points together in a sequential fashion, you form the surface of Mars.
        val currentPoint = Point(landX, landY)
        if (i > 0) {
            val previousPoint = points.get(i - 1)
            if (previousPoint.asSameHeightAs(currentPoint)) {
                if (previousPoint.distanceAlongXAxis(currentPoint) >= 1000) {
                    startOfFlatGround = previousPoint
                    endOfFlatGround = currentPoint
                }
            }
        }
        if (currentPoint.isStrictlyHigherThan(highestPoint)) {
            highestPoint = currentPoint
        }
        points.add(currentPoint)
    }

    System.err.println("Found flat area between ${startOfFlatGround} and ${endOfFlatGround}")

    // game loop
    while (true) {
        val X = input.nextInt()
        val Y = input.nextInt()
        val hSpeed = input.nextInt() // the horizontal speed (in m/s), can be negative.
        val vSpeed = input.nextInt() // the vertical speed (in m/s), can be negative.
        val fuel = input.nextInt() // the quantity of remaining fuel in liters.
        val rotate = input.nextInt() // the rotation angle in degrees (-90 to 90).
        val power = input.nextInt() // the thrust power (0 to 4).

        // Write an action using println()
        // To debug: System.err.println("Debug messages...");
        // Where am I ?
        // If above the flatground, that's ok, I have only to descend with
        // - rotation == 0
        // - hSpeed <= 20
        // - vSpeed <= 40
        // If on the left of the minX, I have to rotate negatively and thrust to max to go on left until I am above flat ground
        // If on the right of the maxX, I have to rotate positively and thrust to max to go on right until I am above flat ground
        val answer = when (X) {
            in 0..startOfFlatGround.x -> goRight(hSpeed, vSpeed, fuel, rotate, power)
            in endOfFlatGround.x..6999 -> goLeft(hSpeed, vSpeed, fuel, rotate, power)
            in startOfFlatGround.x..endOfFlatGround.x -> goDown(hSpeed, vSpeed, fuel, rotate, power)
            else -> goDown(hSpeed, vSpeed, fuel, rotate, power)
        }

        // rotate power. rotate is the desired rotation angle. power is the desired thrust power.
        println(answer)
    }
}

data class Point(val x: Int = 0, val y: Int = 0) {
    fun isStrictlyHigherThan(other:Point):Boolean {
        return this.y > other.y
    }

    fun isStrictlyLowerThan(other: Point):Boolean {
        return this.y < other.y
    }

    fun asSameHeightAs(other: Point):Boolean {
        return this.y == other.y;
    }

    fun distanceAlongXAxis(other: Point): Int {
        return Math.abs(other.x - this.x)
    }

    fun distanceAlongYAxis(other: Point): Int {
        return Math.abs(other.y - this.y)
    }

    fun distance(other:Point): Double {
        return Math.sqrt(Math.pow((other.x - this.x).toDouble(),2.0) + Math.pow((other.y - this.y).toDouble(),2.0))
    }
}

fun goDown(hSpeed: Int, vSpeed: Int, fuel: Int, rotate: Int, power: Int): String {
    var result = ""

    if (hSpeed > 19) {
        return "15 ${Integer.toString(Math.max(0, power - 1))}"
    } else if (hSpeed < -19) {
        return "-15 ${Integer.toString(Math.min(4, power + 1))}"
    } else {
        if (vSpeed > 39) {
            result = "0 ${Integer.toString(Math.max(0, power - 1))}"
        } else if (vSpeed < -39) {
            result = "0 ${Integer.toString(Math.min(4, power + 1))}"
        } else {
            result = "0 0"
        }
    }
    return result
}

fun goLeft(hSpeed: Int, vSpeed: Int, fuel: Int, rotate: Int, power: Int): String {
    //return "90 4"
    return if (hSpeed > 19) {
        "45 ${Integer.toString(Math.max(0, power - 1))}"
    } else if (hSpeed < -19) {
        "-45 ${Integer.toString(Math.min(4, power + 1))}"
    } else {
        "0 0"
    }
}

fun goRight(hSpeed: Int, vSpeed: Int, fuel: Int, rotate: Int, power: Int): String {
    //return "-90 4"
    return if (hSpeed > 19) {
        "45 ${Integer.toString(Math.max(0, power - 1))}"
    } else if (hSpeed < -19) {
        "-45 ${Integer.toString(Math.min(4, power + 1))}"
    } else {
        "0 0"
    }
}


